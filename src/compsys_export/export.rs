use crate::spec::{ArgSpec, CommandSpec, OptionSpec, SubcommandSpec};

use super::format::{escape_zsh_string, format_arg, format_option};

pub(super) fn export_command_spec(spec: &CommandSpec) -> String {
    let mut out = String::new();

    out.push_str(&format!("#compdef {}\n", spec.name));
    out.push_str("# Auto-generated by synapse -- do not edit manually\n");
    let source_label = match spec.source {
        crate::spec::SpecSource::Discovered => "discovered (parsed from --help)",
        crate::spec::SpecSource::ProjectAuto => "project-auto",
    };
    out.push_str(&format!("# Source: {source_label}\n"));
    out.push_str(&format!(
        "# Generated: {}\n",
        chrono::Utc::now().format("%Y-%m-%dT%H:%M:%SZ")
    ));
    out.push_str("# Regenerate with: synapse generate-completions --force\n\n");

    let fn_name = format!("_{}", spec.name.replace('-', "_"));

    if spec.recursive {
        export_recursive_command(&mut out, &fn_name, &spec.options);
    } else if spec.subcommands.is_empty() {
        export_simple_command(&mut out, &fn_name, &spec.options, &spec.args);
    } else {
        export_subcommand_command(&mut out, &fn_name, spec);
    }

    out.push_str(&format!("\n{fn_name} \"$@\"\n"));

    for alias in &spec.aliases {
        out.push_str(&format!("compdef {fn_name} {alias}\n"));
    }

    out
}

fn export_simple_command(
    out: &mut String,
    fn_name: &str,
    options: &[OptionSpec],
    args: &[ArgSpec],
) {
    out.push_str(&format!("{fn_name}() {{\n"));
    out.push_str("    _arguments \\\n");

    for option in options {
        let line = format_option(option);
        out.push_str(&format!("        {line} \\\n"));
    }

    for arg in args {
        let line = format_arg(arg);
        out.push_str(&format!("        {line} \\\n"));
    }

    if out.ends_with(" \\\n") {
        out.truncate(out.len() - 3);
        out.push('\n');
    }
    out.push_str("}\n");
}

fn export_recursive_command(out: &mut String, fn_name: &str, options: &[OptionSpec]) {
    out.push_str(&format!("{fn_name}() {{\n"));
    out.push_str("    _arguments \\\n");

    for option in options {
        let line = format_option(option);
        out.push_str(&format!("        {line} \\\n"));
    }

    out.push_str("        '(-):command:_command_names -e' \\\n");
    out.push_str("        '*::args:_normal'\n");
    out.push_str("}\n");
}

fn export_subcommand_command(out: &mut String, fn_name: &str, spec: &CommandSpec) {
    export_dispatch_command(out, fn_name, &spec.options, &spec.subcommands);

    for sub in &spec.subcommands {
        let sub_fn_name = subcommand_fn_name(fn_name, &sub.name);
        out.push('\n');
        export_subcommand_fn(out, &sub_fn_name, sub);
    }
}

fn subcommand_fn_name(parent_fn_name: &str, subcommand_name: &str) -> String {
    format!("{parent_fn_name}_{}", subcommand_name.replace('-', "_"))
}

fn subcommand_pattern(sub: &SubcommandSpec) -> String {
    if sub.aliases.is_empty() {
        format!("({})", sub.name)
    } else {
        let all: Vec<&str> = std::iter::once(sub.name.as_str())
            .chain(sub.aliases.iter().map(|alias| alias.as_str()))
            .collect();
        format!("({})", all.join("|"))
    }
}

fn export_dispatch_command(
    out: &mut String,
    fn_name: &str,
    options: &[OptionSpec],
    subcommands: &[SubcommandSpec],
) {
    out.push_str(&format!("{fn_name}() {{\n"));
    out.push_str("    local curcontext=\"$curcontext\" state line\n");
    out.push_str("    typeset -A opt_args\n\n");
    out.push_str("    _arguments -C \\\n");

    for option in options {
        let line = format_option(option);
        out.push_str(&format!("        {line} \\\n"));
    }

    out.push_str("        '1:command:->cmd' \\\n");
    out.push_str("        '*::args:->args'\n\n");
    out.push_str("    case $state in\n");
    out.push_str("        (cmd)\n");
    out.push_str("            local -a commands=(\n");

    for sub in subcommands {
        let desc = sub.description.as_deref().unwrap_or("");
        let escaped_desc = escape_zsh_string(desc);
        out.push_str(&format!(
            "                '{}:{}'\n",
            sub.name, escaped_desc
        ));
    }

    out.push_str("            )\n");
    out.push_str("            _describe 'command' commands\n");
    out.push_str("            ;;\n");
    out.push_str("        (args)\n");
    out.push_str("            case ${line[1]} in\n");

    for sub in subcommands {
        let sub_fn_name = subcommand_fn_name(fn_name, &sub.name);
        let pattern = subcommand_pattern(sub);
        out.push_str(&format!("                {pattern} {sub_fn_name} ;;\n"));
    }

    out.push_str("            esac\n");
    out.push_str("            ;;\n");
    out.push_str("    esac\n");
    out.push_str("}\n");
}

fn export_subcommand_fn(out: &mut String, fn_name: &str, sub: &SubcommandSpec) {
    if !sub.subcommands.is_empty() {
        export_dispatch_command(out, fn_name, &sub.options, &sub.subcommands);

        for nested in &sub.subcommands {
            let nested_fn = subcommand_fn_name(fn_name, &nested.name);
            out.push('\n');
            export_subcommand_fn(out, &nested_fn, nested);
        }
    } else {
        out.push_str(&format!("{fn_name}() {{\n"));
        out.push_str("    _arguments \\\n");

        for option in &sub.options {
            let line = format_option(option);
            out.push_str(&format!("        {line} \\\n"));
        }

        for arg in &sub.args {
            let line = format_arg(arg);
            out.push_str(&format!("        {line} \\\n"));
        }

        if out.ends_with(" \\\n") {
            out.truncate(out.len() - 3);
            out.push('\n');
        }
        out.push_str("}\n");
    }
}
