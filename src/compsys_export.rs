//! Convert `CommandSpec` into zsh `_arguments`-style completion functions.
//!
//! This module is the core of the compsys export system. It takes Synapse's
//! `CommandSpec` data model and generates standard zsh completion functions
//! that work with compsys, fzf-tab, and any other `_arguments`-based tool.

use std::collections::HashSet;
use std::io;
use std::path::{Path, PathBuf};

use crate::spec::{ArgSpec, ArgTemplate, CommandSpec, GeneratorSpec, OptionSpec, SubcommandSpec};

/// Return the default completions directory (~/.local/share/synapse/completions/).
pub fn completions_dir() -> PathBuf {
    dirs::data_local_dir()
        .or_else(|| dirs::home_dir().map(|h| h.join(".local").join("share")))
        .unwrap_or_else(|| PathBuf::from("/tmp"))
        .join("synapse")
        .join("completions")
}

/// Generate a complete zsh completion function from a CommandSpec.
pub fn export_command_spec(spec: &CommandSpec) -> String {
    let mut out = String::new();

    // Header
    out.push_str(&format!("#compdef {}\n", spec.name));
    out.push_str("# Auto-generated by synapse -- do not edit manually\n");
    let source_label = match spec.source {
        crate::spec::SpecSource::Discovered => "discovered (parsed from --help)",
        crate::spec::SpecSource::ProjectAuto => "project-auto",
    };
    out.push_str(&format!("# Source: {source_label}\n"));
    out.push_str(&format!(
        "# Generated: {}\n",
        chrono::Utc::now().format("%Y-%m-%dT%H:%M:%SZ")
    ));
    out.push_str("# Regenerate with: synapse generate-completions --force\n");
    out.push('\n');

    let fn_name = format!("_{}", spec.name.replace('-', "_"));

    if spec.recursive {
        export_recursive_command(&mut out, &fn_name, &spec.options);
    } else if spec.subcommands.is_empty() {
        export_simple_command(&mut out, &fn_name, &spec.options, &spec.args);
    } else {
        export_subcommand_command(&mut out, &fn_name, spec);
    }

    // compdef line
    out.push_str(&format!("\n{fn_name} \"$@\"\n"));

    // Aliases
    for alias in &spec.aliases {
        out.push_str(&format!("compdef {fn_name} {alias}\n"));
    }

    out
}

/// Write the completion function to a file in the given directory.
/// Returns the path to the written file.
pub fn write_completion_file(spec: &CommandSpec, dir: &Path) -> io::Result<PathBuf> {
    std::fs::create_dir_all(dir)?;
    let filename = format!("_{}", spec.name);
    let path = dir.join(filename);
    let content = export_command_spec(spec);
    std::fs::write(&path, content)?;
    Ok(path)
}

/// Report from a generate_all run.
#[derive(Debug, Default)]
pub struct GenerationReport {
    pub generated: Vec<String>,
    pub skipped_existing: Vec<String>,
}

/// Generate completions for all specs, skipping commands with existing compsys functions.
pub fn generate_all(
    specs: &[CommandSpec],
    existing_commands: &HashSet<String>,
    output_dir: &Path,
    gap_only: bool,
) -> io::Result<GenerationReport> {
    std::fs::create_dir_all(output_dir)?;
    let mut report = GenerationReport::default();

    for spec in specs {
        if spec.name.is_empty() {
            continue;
        }

        let is_project_auto = spec.source == crate::spec::SpecSource::ProjectAuto;

        // Project-auto specs always generate (they provide project-specific completions)
        if gap_only && !is_project_auto && existing_commands.contains(&spec.name) {
            report.skipped_existing.push(spec.name.clone());
            continue;
        }

        write_completion_file(spec, output_dir)?;
        report.generated.push(spec.name.clone());
    }

    Ok(report)
}

// --- Internal export functions ---

/// Export a simple command (no subcommands).
fn export_simple_command(
    out: &mut String,
    fn_name: &str,
    options: &[OptionSpec],
    args: &[ArgSpec],
) {
    out.push_str(&format!("{fn_name}() {{\n"));
    out.push_str("    _arguments \\\n");

    for opt in options {
        let line = format_option(opt);
        out.push_str(&format!("        {line} \\\n"));
    }

    for arg in args {
        let line = format_arg(arg);
        out.push_str(&format!("        {line} \\\n"));
    }

    // If no args specified, allow files as default
    if args.is_empty()
        && options
            .iter()
            .all(|o| !o.takes_arg || o.long.is_some() || o.short.is_some())
    {
        // Just close the _arguments call
    }

    // Remove trailing " \\\n" from last line and close
    if out.ends_with(" \\\n") {
        out.truncate(out.len() - 3);
        out.push('\n');
    }
    out.push_str("}\n");
}

/// Export a recursive command (sudo, env) that dispatches to _normal.
fn export_recursive_command(out: &mut String, fn_name: &str, options: &[OptionSpec]) {
    out.push_str(&format!("{fn_name}() {{\n"));
    out.push_str("    _arguments \\\n");

    for opt in options {
        let line = format_option(opt);
        out.push_str(&format!("        {line} \\\n"));
    }

    out.push_str("        '(-):command:_command_names -e' \\\n");
    out.push_str("        '*::args:_normal'\n");
    out.push_str("}\n");
}

/// Export a command with subcommands using _arguments -C and state dispatch.
fn export_subcommand_command(out: &mut String, fn_name: &str, spec: &CommandSpec) {
    out.push_str(&format!("{fn_name}() {{\n"));
    out.push_str("    local curcontext=\"$curcontext\" state line\n");
    out.push_str("    typeset -A opt_args\n");
    out.push('\n');
    out.push_str("    _arguments -C \\\n");

    for opt in &spec.options {
        let line = format_option(opt);
        out.push_str(&format!("        {line} \\\n"));
    }

    out.push_str("        '1:command:->cmd' \\\n");
    out.push_str("        '*::args:->args'\n");
    out.push('\n');
    out.push_str("    case $state in\n");
    out.push_str("        (cmd)\n");
    out.push_str("            local -a commands=(\n");

    for sub in &spec.subcommands {
        let desc = sub.description.as_deref().unwrap_or("");
        let escaped_desc = escape_zsh_string(desc);
        out.push_str(&format!(
            "                '{}:{}'\n",
            sub.name, escaped_desc
        ));
    }

    out.push_str("            )\n");
    out.push_str("            _describe 'command' commands\n");
    out.push_str("            ;;\n");
    out.push_str("        (args)\n");
    out.push_str("            case ${line[1]} in\n");

    for sub in &spec.subcommands {
        let sub_fn_name = format!("{fn_name}_{}", sub.name.replace('-', "_"));
        let pattern = if sub.aliases.is_empty() {
            format!("({})", sub.name)
        } else {
            let all: Vec<&str> = std::iter::once(sub.name.as_str())
                .chain(sub.aliases.iter().map(|a| a.as_str()))
                .collect();
            format!("({})", all.join("|"))
        };
        out.push_str(&format!("                {pattern} {sub_fn_name} ;;\n"));
    }

    out.push_str("            esac\n");
    out.push_str("            ;;\n");
    out.push_str("    esac\n");
    out.push_str("}\n");

    // Generate subcommand functions
    for sub in &spec.subcommands {
        let sub_fn_name = format!("{fn_name}_{}", sub.name.replace('-', "_"));
        out.push('\n');
        export_subcommand_fn(out, &sub_fn_name, sub);
    }
}

/// Export a subcommand function (recursive for nested subcommands).
fn export_subcommand_fn(out: &mut String, fn_name: &str, sub: &SubcommandSpec) {
    if !sub.subcommands.is_empty() {
        // Nested subcommands — use _arguments -C with state dispatch
        out.push_str(&format!("{fn_name}() {{\n"));
        out.push_str("    local curcontext=\"$curcontext\" state line\n");
        out.push_str("    typeset -A opt_args\n");
        out.push('\n');
        out.push_str("    _arguments -C \\\n");

        for opt in &sub.options {
            let line = format_option(opt);
            out.push_str(&format!("        {line} \\\n"));
        }

        out.push_str("        '1:command:->cmd' \\\n");
        out.push_str("        '*::args:->args'\n");
        out.push('\n');
        out.push_str("    case $state in\n");
        out.push_str("        (cmd)\n");
        out.push_str("            local -a commands=(\n");

        for nested in &sub.subcommands {
            let desc = nested.description.as_deref().unwrap_or("");
            let escaped_desc = escape_zsh_string(desc);
            out.push_str(&format!(
                "                '{}:{}'\n",
                nested.name, escaped_desc
            ));
        }

        out.push_str("            )\n");
        out.push_str("            _describe 'command' commands\n");
        out.push_str("            ;;\n");
        out.push_str("        (args)\n");
        out.push_str("            case ${line[1]} in\n");

        for nested in &sub.subcommands {
            let nested_fn = format!("{fn_name}_{}", nested.name.replace('-', "_"));
            let pattern = if nested.aliases.is_empty() {
                format!("({})", nested.name)
            } else {
                let all: Vec<&str> = std::iter::once(nested.name.as_str())
                    .chain(nested.aliases.iter().map(|a| a.as_str()))
                    .collect();
                format!("({})", all.join("|"))
            };
            out.push_str(&format!("                {pattern} {nested_fn} ;;\n"));
        }

        out.push_str("            esac\n");
        out.push_str("            ;;\n");
        out.push_str("    esac\n");
        out.push_str("}\n");

        // Recurse into nested subcommands
        for nested in &sub.subcommands {
            let nested_fn = format!("{fn_name}_{}", nested.name.replace('-', "_"));
            out.push('\n');
            export_subcommand_fn(out, &nested_fn, nested);
        }
    } else {
        // Leaf subcommand — simple _arguments
        out.push_str(&format!("{fn_name}() {{\n"));
        out.push_str("    _arguments \\\n");

        for opt in &sub.options {
            let line = format_option(opt);
            out.push_str(&format!("        {line} \\\n"));
        }

        for arg in &sub.args {
            let line = format_arg(arg);
            out.push_str(&format!("        {line} \\\n"));
        }

        if out.ends_with(" \\\n") {
            out.truncate(out.len() - 3);
            out.push('\n');
        }
        out.push_str("}\n");
    }
}

/// Format a single OptionSpec as a zsh _arguments option string.
fn format_option(opt: &OptionSpec) -> String {
    let desc = opt
        .description
        .as_deref()
        .map(escape_zsh_string)
        .unwrap_or_default();

    let arg_suffix = if opt.takes_arg {
        // If the option has an arg_generator, add a completion action
        if let Some(ref gen) = opt.arg_generator {
            format!("::{}", format_generator_action(gen))
        } else {
            ": :".to_string()
        }
    } else {
        String::new()
    };

    match (opt.short.as_deref(), opt.long.as_deref()) {
        (Some(short), Some(long)) => {
            let eq = if opt.takes_arg { "=" } else { "" };
            format!("'({short} {long})'{{{short},{long}{eq}}}'[{desc}]'{arg_suffix}")
        }
        (None, Some(long)) => {
            let eq = if opt.takes_arg { "=" } else { "" };
            format!("'{long}{eq}[{desc}]'{arg_suffix}")
        }
        (Some(short), None) => {
            format!("'{short}[{desc}]'{arg_suffix}")
        }
        (None, None) => String::new(),
    }
}

/// Format an ArgSpec as a zsh _arguments argument string.
fn format_arg(arg: &ArgSpec) -> String {
    let prefix = if arg.variadic { "*" } else { "" };

    if let Some(ref template) = arg.template {
        return match template {
            ArgTemplate::FilePaths => format!("'{prefix}:file:_files'"),
            ArgTemplate::Directories => format!("'{prefix}:directory:_files -/'"),
            ArgTemplate::EnvVars => {
                format!("'{prefix}:variable:_parameters -g \"*(export)\"'")
            }
            ArgTemplate::History => format!("'{prefix}:arg:'"),
        };
    }

    if !arg.suggestions.is_empty() {
        let values = arg
            .suggestions
            .iter()
            .map(|s| escape_zsh_string(s))
            .collect::<Vec<_>>()
            .join(" ");
        let name = if arg.name.is_empty() {
            "arg"
        } else {
            &arg.name
        };
        return format!("'{prefix}:{name}:({values})'");
    }

    if let Some(ref generator) = arg.generator {
        let action = format_generator_action(generator);
        // Escape single quotes since the action is embedded inside a single-quoted
        // _arguments spec. Generator commands often contain single quotes
        // (e.g. awk '{print $1}', docker --format '{{.Names}}').
        let action = action.replace('\'', "'\\''");
        let name = if arg.name.is_empty() {
            "arg"
        } else {
            &arg.name
        };
        return format!("'{prefix}:{name}:{action}'");
    }

    // No completions specified — just a positional arg name
    let name = if arg.name.is_empty() {
        "arg"
    } else {
        &arg.name
    };
    format!("'{prefix}:{name}:'")
}

/// Format a GeneratorSpec as a zsh completion action.
fn format_generator_action(gen: &GeneratorSpec) -> String {
    let cmd = &gen.command;

    // Build the processing pipeline
    let mut pipeline = String::new();

    // Strip prefix if specified
    if let Some(ref prefix) = gen.strip_prefix {
        // Escape sed regex metacharacters in the prefix
        let escaped = prefix
            .replace('\\', r"\\")
            .replace('/', r"\/")
            .replace('.', r"\.")
            .replace('*', r"\*")
            .replace('[', r"\[")
            .replace(']', r"\]")
            .replace('^', r"\^")
            .replace('$', r"\$")
            .replace('"', r#"\""#);
        pipeline.push_str(&format!(" | sed \"s/^{escaped}//\""));
    }

    // Split parameter
    let split_flag = if gen.split_on == "\n" {
        "(f)".to_string()
    } else {
        format!("(s:{}:)", gen.split_on)
    };

    format!(
        "{{local -a vals; vals=(${{{}\"$({cmd}{pipeline} 2>/dev/null)\"}}); compadd -a vals}}",
        split_flag
    )
}

/// Escape a string for use inside zsh single-quoted contexts.
/// Single quotes inside _arguments descriptions need special handling.
fn escape_zsh_string(s: &str) -> String {
    s.replace('\'', "'\\''")
        .replace('[', "\\[")
        .replace(']', "\\]")
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::spec::*;

    #[test]
    fn test_format_option_short_and_long_flag() {
        let opt = OptionSpec {
            short: Some("-v".into()),
            long: Some("--verbose".into()),
            description: Some("Verbose".into()),
            takes_arg: false,
            ..Default::default()
        };
        let result = format_option(&opt);
        assert_eq!(result, "'(-v --verbose)'{-v,--verbose}'[Verbose]'");
    }

    #[test]
    fn test_format_option_short_and_long_with_arg() {
        let opt = OptionSpec {
            short: Some("-o".into()),
            long: Some("--output".into()),
            description: Some("Output file".into()),
            takes_arg: true,
            ..Default::default()
        };
        let result = format_option(&opt);
        assert_eq!(result, "'(-o --output)'{-o,--output=}'[Output file]': :");
    }

    #[test]
    fn test_format_option_long_only_with_arg() {
        let opt = OptionSpec {
            long: Some("--port".into()),
            description: Some("Port".into()),
            takes_arg: true,
            ..Default::default()
        };
        let result = format_option(&opt);
        assert_eq!(result, "'--port=[Port]': :");
    }

    #[test]
    fn test_format_option_short_only_with_arg() {
        let opt = OptionSpec {
            short: Some("-j".into()),
            description: Some("Jobs".into()),
            takes_arg: true,
            ..Default::default()
        };
        let result = format_option(&opt);
        assert_eq!(result, "'-j[Jobs]': :");
    }

    #[test]
    fn test_format_option_long_only_flag() {
        let opt = OptionSpec {
            long: Some("--release".into()),
            description: Some("Build in release mode".into()),
            takes_arg: false,
            ..Default::default()
        };
        let result = format_option(&opt);
        assert_eq!(result, "'--release[Build in release mode]'");
    }

    #[test]
    fn test_format_arg_file_paths() {
        let arg = ArgSpec {
            name: "file".into(),
            template: Some(ArgTemplate::FilePaths),
            variadic: true,
            ..Default::default()
        };
        assert_eq!(format_arg(&arg), "'*:file:_files'");
    }

    #[test]
    fn test_format_arg_directories() {
        let arg = ArgSpec {
            name: "dir".into(),
            template: Some(ArgTemplate::Directories),
            ..Default::default()
        };
        assert_eq!(format_arg(&arg), "':directory:_files -/'");
    }

    #[test]
    fn test_format_arg_env_vars() {
        let arg = ArgSpec {
            name: "var".into(),
            template: Some(ArgTemplate::EnvVars),
            ..Default::default()
        };
        assert_eq!(format_arg(&arg), "':variable:_parameters -g \"*(export)\"'");
    }

    #[test]
    fn test_format_arg_suggestions() {
        let arg = ArgSpec {
            name: "color".into(),
            suggestions: vec!["auto".into(), "always".into(), "never".into()],
            ..Default::default()
        };
        assert_eq!(format_arg(&arg), "':color:(auto always never)'");
    }

    #[test]
    fn test_format_arg_generator() {
        let arg = ArgSpec {
            name: "branch".into(),
            generator: Some(GeneratorSpec {
                command: "git branch --no-color".into(),
                strip_prefix: Some("* ".into()),
                split_on: "\n".into(),
                ..Default::default()
            }),
            ..Default::default()
        };
        let result = format_arg(&arg);
        assert!(result.contains("git branch --no-color"));
        assert!(result.contains("sed"));
        assert!(result.contains("compadd"));
    }

    #[test]
    fn test_format_arg_generator_escapes_single_quotes() {
        let arg = ArgSpec {
            name: "column".into(),
            generator: Some(GeneratorSpec {
                command: "awk '{print $1}' /some/file".into(),
                split_on: "\n".into(),
                ..Default::default()
            }),
            ..Default::default()
        };
        let result = format_arg(&arg);
        // Inner single quotes are escaped as '\'' (end quote, literal quote, reopen).
        // The original "awk '{print $1}'" becomes "awk '\''{print $1}'\'' ..."
        assert!(
            result.contains("awk '\\''"),
            "Expected escaped single quote before {{print, got: {result}"
        );
        assert!(
            result.contains("$1}'\\''"),
            "Expected escaped single quote after $1}}, got: {result}"
        );
    }

    #[test]
    fn test_export_simple_command() {
        let spec = CommandSpec {
            name: "myapp".into(),
            options: vec![OptionSpec {
                short: Some("-v".into()),
                long: Some("--verbose".into()),
                description: Some("Verbose output".into()),
                takes_arg: false,
                ..Default::default()
            }],
            args: vec![ArgSpec {
                name: "file".into(),
                template: Some(ArgTemplate::FilePaths),
                variadic: true,
                ..Default::default()
            }],
            ..Default::default()
        };
        let output = export_command_spec(&spec);
        assert!(output.contains("#compdef myapp"));
        assert!(output.contains("_myapp()"));
        assert!(output.contains("_arguments"));
        assert!(output.contains("--verbose"));
        assert!(output.contains("_files"));
        assert!(output.contains("_myapp \"$@\""));
    }

    #[test]
    fn test_export_recursive_command() {
        let spec = CommandSpec {
            name: "sudo".into(),
            recursive: true,
            options: vec![OptionSpec {
                short: Some("-u".into()),
                description: Some("Run as user".into()),
                takes_arg: true,
                ..Default::default()
            }],
            ..Default::default()
        };
        let output = export_command_spec(&spec);
        assert!(output.contains("_command_names -e"));
        assert!(output.contains("*::args:_normal"));
    }

    #[test]
    fn test_export_command_with_subcommands() {
        let spec = CommandSpec {
            name: "cargo".into(),
            options: vec![OptionSpec {
                short: Some("-V".into()),
                long: Some("--version".into()),
                description: Some("Print version".into()),
                takes_arg: false,
                ..Default::default()
            }],
            subcommands: vec![
                SubcommandSpec {
                    name: "build".into(),
                    aliases: vec!["b".into()],
                    description: Some("Compile the current package".into()),
                    options: vec![OptionSpec {
                        long: Some("--release".into()),
                        description: Some("Build in release mode".into()),
                        takes_arg: false,
                        ..Default::default()
                    }],
                    ..Default::default()
                },
                SubcommandSpec {
                    name: "test".into(),
                    aliases: vec!["t".into()],
                    description: Some("Run tests".into()),
                    ..Default::default()
                },
            ],
            ..Default::default()
        };
        let output = export_command_spec(&spec);
        assert!(output.contains("#compdef cargo"));
        assert!(output.contains("_cargo()"));
        assert!(output.contains("_arguments -C"));
        assert!(output.contains("'1:command:->cmd'"));
        assert!(output.contains("*::args:->args"));
        assert!(output.contains("'build:Compile the current package'"));
        assert!(output.contains("'test:Run tests'"));
        assert!(output.contains("(build|b) _cargo_build"));
        assert!(output.contains("(test|t) _cargo_test"));
        assert!(output.contains("_cargo_build()"));
        assert!(output.contains("--release"));
    }

    #[test]
    fn test_export_nested_subcommands() {
        let spec = CommandSpec {
            name: "git".into(),
            subcommands: vec![SubcommandSpec {
                name: "stash".into(),
                description: Some("Stash changes".into()),
                subcommands: vec![
                    SubcommandSpec {
                        name: "push".into(),
                        description: Some("Save modifications".into()),
                        options: vec![OptionSpec {
                            short: Some("-m".into()),
                            long: Some("--message".into()),
                            description: Some("Stash message".into()),
                            takes_arg: true,
                            ..Default::default()
                        }],
                        ..Default::default()
                    },
                    SubcommandSpec {
                        name: "pop".into(),
                        description: Some("Apply and remove stash".into()),
                        ..Default::default()
                    },
                ],
                ..Default::default()
            }],
            ..Default::default()
        };
        let output = export_command_spec(&spec);
        assert!(output.contains("_git_stash()"));
        assert!(output.contains("_git_stash_push()"));
        assert!(output.contains("_git_stash_pop()"));
        assert!(output.contains("'push:Save modifications'"));
        assert!(output.contains("--message"));
    }

    #[test]
    fn test_export_command_with_aliases() {
        let spec = CommandSpec {
            name: "cargo".into(),
            aliases: vec!["cg".into()],
            ..Default::default()
        };
        let output = export_command_spec(&spec);
        assert!(output.contains("compdef _cargo cg"));
    }

    #[test]
    fn test_write_completion_file() {
        let dir = tempfile::tempdir().unwrap();
        let spec = CommandSpec {
            name: "testcmd".into(),
            ..Default::default()
        };
        let path = write_completion_file(&spec, dir.path()).unwrap();
        assert_eq!(path.file_name().unwrap(), "_testcmd");
        assert!(path.exists());
        let content = std::fs::read_to_string(&path).unwrap();
        assert!(content.contains("#compdef testcmd"));
    }

    #[test]
    fn test_generate_all_gap_only() {
        let dir = tempfile::tempdir().unwrap();
        let mut existing = HashSet::new();
        existing.insert("rg".to_string());

        let specs = vec![
            CommandSpec {
                name: "rg".into(),
                source: SpecSource::Discovered,
                ..Default::default()
            },
            CommandSpec {
                name: "fd".into(),
                source: SpecSource::Discovered,
                ..Default::default()
            },
        ];

        let report = generate_all(&specs, &existing, dir.path(), true).unwrap();
        assert_eq!(report.generated, vec!["fd"]);
        assert_eq!(report.skipped_existing, vec!["rg"]);
    }

    #[test]
    fn test_generate_all_project_auto_always_generates() {
        let dir = tempfile::tempdir().unwrap();
        let mut existing = HashSet::new();
        existing.insert("make".to_string());

        let specs = vec![CommandSpec {
            name: "make".into(),
            source: SpecSource::ProjectAuto,
            ..Default::default()
        }];

        let report = generate_all(&specs, &existing, dir.path(), true).unwrap();
        assert_eq!(report.generated, vec!["make"]);
        assert!(report.skipped_existing.is_empty());
    }

    #[test]
    fn test_format_generator_action_with_strip_prefix() {
        let gen = GeneratorSpec {
            command: "git branch --no-color".into(),
            strip_prefix: Some("* ".into()),
            split_on: "\n".into(),
            ..Default::default()
        };
        let action = format_generator_action(&gen);
        assert!(action.contains("git branch --no-color"));
        assert!(action.contains("sed \"s/^\\* //\""));
        assert!(action.contains("compadd -a vals"));
    }

    #[test]
    fn test_format_generator_action_simple() {
        let gen = GeneratorSpec {
            command: "git remote".into(),
            split_on: "\n".into(),
            ..Default::default()
        };
        let action = format_generator_action(&gen);
        assert!(action.contains("git remote"));
        assert!(action.contains("(f)"));
        assert!(!action.contains("sed"));
    }

    #[test]
    fn test_escape_zsh_string() {
        assert_eq!(escape_zsh_string("hello"), "hello");
        assert_eq!(escape_zsh_string("it's"), "it'\\''s");
        assert_eq!(escape_zsh_string("[test]"), "\\[test\\]");
    }

    #[test]
    fn test_option_with_arg_generator() {
        let opt = OptionSpec {
            long: Some("--color".into()),
            description: Some("Coloring".into()),
            takes_arg: true,
            arg_generator: None,
            ..Default::default()
        };
        let result = format_option(&opt);
        assert_eq!(result, "'--color=[Coloring]': :");
    }

    #[test]
    fn test_completions_dir() {
        let dir = completions_dir();
        assert!(dir.ends_with("synapse/completions"));
    }
}
