//! Convert `CommandSpec` into zsh `_arguments`-style completion functions.
//!
//! This module is the core of the compsys export system. It takes Synapse's
//! `CommandSpec` data model and generates standard zsh completion functions
//! that work with compsys, fzf-tab, and any other `_arguments`-based tool.

use std::collections::HashSet;
use std::io;
use std::path::{Path, PathBuf};

use crate::spec::{ArgSpec, ArgTemplate, CommandSpec, GeneratorSpec, OptionSpec, SubcommandSpec};

/// Return the default completions directory (~/.synapse/completions/).
pub fn completions_dir() -> PathBuf {
    dirs::home_dir()
        .unwrap_or_else(|| PathBuf::from("/tmp"))
        .join(".synapse")
        .join("completions")
}

/// Generate a complete zsh completion function from a CommandSpec.
pub fn export_command_spec(spec: &CommandSpec) -> String {
    let mut out = String::new();

    // Header
    out.push_str(&format!("#compdef {}\n", spec.name));
    out.push_str("# Auto-generated by synapse -- do not edit manually\n");
    let source_label = match spec.source {
        crate::spec::SpecSource::Discovered => "discovered (parsed from --help)",
        crate::spec::SpecSource::ProjectAuto => "project-auto",
    };
    out.push_str(&format!("# Source: {source_label}\n"));
    out.push_str(&format!(
        "# Generated: {}\n",
        chrono::Utc::now().format("%Y-%m-%dT%H:%M:%SZ")
    ));
    out.push_str("# Regenerate with: synapse generate-completions --force\n");
    out.push('\n');

    let fn_name = format!("_{}", spec.name.replace('-', "_"));

    if spec.recursive {
        export_recursive_command(&mut out, &fn_name, &spec.options);
    } else if spec.subcommands.is_empty() {
        export_simple_command(&mut out, &fn_name, &spec.options, &spec.args);
    } else {
        export_subcommand_command(&mut out, &fn_name, spec);
    }

    // compdef line
    out.push_str(&format!("\n{fn_name} \"$@\"\n"));

    // Aliases
    for alias in &spec.aliases {
        out.push_str(&format!("compdef {fn_name} {alias}\n"));
    }

    out
}

/// Write the completion function to a file in the given directory.
/// Returns the path to the written file.
pub fn write_completion_file(spec: &CommandSpec, dir: &Path) -> io::Result<PathBuf> {
    std::fs::create_dir_all(dir)?;
    let filename = format!("_{}", spec.name);
    let path = dir.join(filename);
    let content = export_command_spec(spec);
    std::fs::write(&path, content)?;
    Ok(path)
}

/// Report from a generate_all run.
#[derive(Debug, Default)]
pub struct GenerationReport {
    pub generated: Vec<String>,
    pub skipped_existing: Vec<String>,
    pub removed: Vec<String>,
}

/// Generate completions for all specs, skipping commands with existing compsys functions.
pub fn generate_all(
    specs: &[CommandSpec],
    existing_commands: &HashSet<String>,
    output_dir: &Path,
    gap_only: bool,
) -> io::Result<GenerationReport> {
    std::fs::create_dir_all(output_dir)?;
    let mut report = GenerationReport::default();

    for spec in specs {
        if spec.name.is_empty() {
            continue;
        }

        let is_project_auto = spec.source == crate::spec::SpecSource::ProjectAuto;

        // Project-auto specs always generate (they provide project-specific completions)
        if gap_only && !is_project_auto && existing_commands.contains(&spec.name) {
            report.skipped_existing.push(spec.name.clone());
            continue;
        }

        write_completion_file(spec, output_dir)?;
        report.generated.push(spec.name.clone());
    }

    Ok(report)
}

/// Remove stale project-auto completion files that weren't regenerated.
///
/// Scans `output_dir` for files with `# Source: project-auto` headers and deletes
/// any whose command name is not in `generated_names`. Returns the list of removed
/// command names.
pub fn remove_stale_project_auto(
    output_dir: &Path,
    generated_names: &HashSet<String>,
) -> io::Result<Vec<String>> {
    let mut removed = Vec::new();
    let entries = match std::fs::read_dir(output_dir) {
        Ok(entries) => entries,
        Err(e) if e.kind() == io::ErrorKind::NotFound => return Ok(removed),
        Err(e) => return Err(e),
    };

    for entry in entries.flatten() {
        let file_name = entry.file_name();
        let name_str = file_name.to_string_lossy();

        // Only consider completion files (start with _)
        if !name_str.starts_with('_') {
            continue;
        }

        let cmd_name = &name_str[1..];
        if generated_names.contains(cmd_name) {
            continue;
        }

        // Read first few lines to check for project-auto source header
        let content = match std::fs::read_to_string(entry.path()) {
            Ok(c) => c,
            Err(_) => continue,
        };

        let is_project_auto = content
            .lines()
            .take(5)
            .any(|line| line == "# Source: project-auto");

        if is_project_auto {
            std::fs::remove_file(entry.path())?;
            removed.push(cmd_name.to_string());
        }
    }

    Ok(removed)
}

// --- Internal export functions ---

/// Export a simple command (no subcommands).
fn export_simple_command(
    out: &mut String,
    fn_name: &str,
    options: &[OptionSpec],
    args: &[ArgSpec],
) {
    out.push_str(&format!("{fn_name}() {{\n"));
    out.push_str("    _arguments \\\n");

    for opt in options {
        let line = format_option(opt);
        out.push_str(&format!("        {line} \\\n"));
    }

    for arg in args {
        let line = format_arg(arg);
        out.push_str(&format!("        {line} \\\n"));
    }

    // If no args specified, allow files as default
    if args.is_empty()
        && options
            .iter()
            .all(|o| !o.takes_arg || o.long.is_some() || o.short.is_some())
    {
        // Just close the _arguments call
    }

    // Remove trailing " \\\n" from last line and close
    if out.ends_with(" \\\n") {
        out.truncate(out.len() - 3);
        out.push('\n');
    }
    out.push_str("}\n");
}

/// Export a recursive command (sudo, env) that dispatches to _normal.
fn export_recursive_command(out: &mut String, fn_name: &str, options: &[OptionSpec]) {
    out.push_str(&format!("{fn_name}() {{\n"));
    out.push_str("    _arguments \\\n");

    for opt in options {
        let line = format_option(opt);
        out.push_str(&format!("        {line} \\\n"));
    }

    out.push_str("        '(-):command:_command_names -e' \\\n");
    out.push_str("        '*::args:_normal'\n");
    out.push_str("}\n");
}

/// Export a command with subcommands using _arguments -C and state dispatch.
fn export_subcommand_command(out: &mut String, fn_name: &str, spec: &CommandSpec) {
    out.push_str(&format!("{fn_name}() {{\n"));
    out.push_str("    local curcontext=\"$curcontext\" state line\n");
    out.push_str("    typeset -A opt_args\n");
    out.push('\n');
    out.push_str("    _arguments -C \\\n");

    for opt in &spec.options {
        let line = format_option(opt);
        out.push_str(&format!("        {line} \\\n"));
    }

    out.push_str("        '1:command:->cmd' \\\n");
    out.push_str("        '*::args:->args'\n");
    out.push('\n');
    out.push_str("    case $state in\n");
    out.push_str("        (cmd)\n");
    out.push_str("            local -a commands=(\n");

    for sub in &spec.subcommands {
        let desc = sub.description.as_deref().unwrap_or("");
        let escaped_desc = escape_zsh_string(desc);
        out.push_str(&format!(
            "                '{}:{}'\n",
            sub.name, escaped_desc
        ));
    }

    out.push_str("            )\n");
    out.push_str("            _describe 'command' commands\n");
    out.push_str("            ;;\n");
    out.push_str("        (args)\n");
    out.push_str("            case ${line[1]} in\n");

    for sub in &spec.subcommands {
        let sub_fn_name = format!("{fn_name}_{}", sub.name.replace('-', "_"));
        let pattern = if sub.aliases.is_empty() {
            format!("({})", sub.name)
        } else {
            let all: Vec<&str> = std::iter::once(sub.name.as_str())
                .chain(sub.aliases.iter().map(|a| a.as_str()))
                .collect();
            format!("({})", all.join("|"))
        };
        out.push_str(&format!("                {pattern} {sub_fn_name} ;;\n"));
    }

    out.push_str("            esac\n");
    out.push_str("            ;;\n");
    out.push_str("    esac\n");
    out.push_str("}\n");

    // Generate subcommand functions
    for sub in &spec.subcommands {
        let sub_fn_name = format!("{fn_name}_{}", sub.name.replace('-', "_"));
        out.push('\n');
        export_subcommand_fn(out, &sub_fn_name, sub);
    }
}

/// Export a subcommand function (recursive for nested subcommands).
fn export_subcommand_fn(out: &mut String, fn_name: &str, sub: &SubcommandSpec) {
    if !sub.subcommands.is_empty() {
        // Nested subcommands — use _arguments -C with state dispatch
        out.push_str(&format!("{fn_name}() {{\n"));
        out.push_str("    local curcontext=\"$curcontext\" state line\n");
        out.push_str("    typeset -A opt_args\n");
        out.push('\n');
        out.push_str("    _arguments -C \\\n");

        for opt in &sub.options {
            let line = format_option(opt);
            out.push_str(&format!("        {line} \\\n"));
        }

        out.push_str("        '1:command:->cmd' \\\n");
        out.push_str("        '*::args:->args'\n");
        out.push('\n');
        out.push_str("    case $state in\n");
        out.push_str("        (cmd)\n");
        out.push_str("            local -a commands=(\n");

        for nested in &sub.subcommands {
            let desc = nested.description.as_deref().unwrap_or("");
            let escaped_desc = escape_zsh_string(desc);
            out.push_str(&format!(
                "                '{}:{}'\n",
                nested.name, escaped_desc
            ));
        }

        out.push_str("            )\n");
        out.push_str("            _describe 'command' commands\n");
        out.push_str("            ;;\n");
        out.push_str("        (args)\n");
        out.push_str("            case ${line[1]} in\n");

        for nested in &sub.subcommands {
            let nested_fn = format!("{fn_name}_{}", nested.name.replace('-', "_"));
            let pattern = if nested.aliases.is_empty() {
                format!("({})", nested.name)
            } else {
                let all: Vec<&str> = std::iter::once(nested.name.as_str())
                    .chain(nested.aliases.iter().map(|a| a.as_str()))
                    .collect();
                format!("({})", all.join("|"))
            };
            out.push_str(&format!("                {pattern} {nested_fn} ;;\n"));
        }

        out.push_str("            esac\n");
        out.push_str("            ;;\n");
        out.push_str("    esac\n");
        out.push_str("}\n");

        // Recurse into nested subcommands
        for nested in &sub.subcommands {
            let nested_fn = format!("{fn_name}_{}", nested.name.replace('-', "_"));
            out.push('\n');
            export_subcommand_fn(out, &nested_fn, nested);
        }
    } else {
        // Leaf subcommand — simple _arguments
        out.push_str(&format!("{fn_name}() {{\n"));
        out.push_str("    _arguments \\\n");

        for opt in &sub.options {
            let line = format_option(opt);
            out.push_str(&format!("        {line} \\\n"));
        }

        for arg in &sub.args {
            let line = format_arg(arg);
            out.push_str(&format!("        {line} \\\n"));
        }

        if out.ends_with(" \\\n") {
            out.truncate(out.len() - 3);
            out.push('\n');
        }
        out.push_str("}\n");
    }
}

/// Format a single OptionSpec as a zsh _arguments option string.
fn format_option(opt: &OptionSpec) -> String {
    let desc = opt
        .description
        .as_deref()
        .map(escape_zsh_string)
        .unwrap_or_default();

    let arg_suffix = if opt.takes_arg {
        // If the option has an arg_generator, add a completion action
        if let Some(ref gen) = opt.arg_generator {
            format!("::{}", format_generator_action(gen))
        } else {
            ": :".to_string()
        }
    } else {
        String::new()
    };

    match (opt.short.as_deref(), opt.long.as_deref()) {
        (Some(short), Some(long)) => {
            let eq = if opt.takes_arg { "=" } else { "" };
            format!("'({short} {long})'{{{short},{long}{eq}}}'[{desc}]'{arg_suffix}")
        }
        (None, Some(long)) => {
            let eq = if opt.takes_arg { "=" } else { "" };
            format!("'{long}{eq}[{desc}]'{arg_suffix}")
        }
        (Some(short), None) => {
            format!("'{short}[{desc}]'{arg_suffix}")
        }
        (None, None) => String::new(),
    }
}

/// Format an ArgSpec as a zsh _arguments argument string.
fn format_arg(arg: &ArgSpec) -> String {
    let prefix = if arg.variadic { "*" } else { "" };

    if let Some(ref template) = arg.template {
        return match template {
            ArgTemplate::FilePaths => format!("'{prefix}:file:_files'"),
            ArgTemplate::Directories => format!("'{prefix}:directory:_files -/'"),
            ArgTemplate::EnvVars => {
                format!("'{prefix}:variable:_parameters -g \"*(export)\"'")
            }
            ArgTemplate::History => format!("'{prefix}:arg:'"),
        };
    }

    if !arg.suggestions.is_empty() {
        let values = arg
            .suggestions
            .iter()
            .map(|s| escape_zsh_string(s))
            .collect::<Vec<_>>()
            .join(" ");
        let name = if arg.name.is_empty() {
            "arg"
        } else {
            &arg.name
        };
        return format!("'{prefix}:{name}:({values})'");
    }

    if let Some(ref generator) = arg.generator {
        let action = format_generator_action(generator);
        // Escape single quotes since the action is embedded inside a single-quoted
        // _arguments spec. Generator commands often contain single quotes
        // (e.g. awk '{print $1}', docker --format '{{.Names}}').
        let action = action.replace('\'', "'\\''");
        let name = if arg.name.is_empty() {
            "arg"
        } else {
            &arg.name
        };
        return format!("'{prefix}:{name}:{action}'");
    }

    // No completions specified — just a positional arg name
    let name = if arg.name.is_empty() {
        "arg"
    } else {
        &arg.name
    };
    format!("'{prefix}:{name}:'")
}

/// Format a GeneratorSpec as a zsh completion action.
///
/// Emits a `synapse run-generator` call that routes through the daemon's
/// timeout and caching infrastructure. Falls back to direct execution
/// with timeout when the daemon is unavailable.
fn format_generator_action(gen: &GeneratorSpec) -> String {
    let cmd_escaped = escape_double_quote_string(&gen.command);
    let mut synapse_cmd = format!("synapse run-generator \"{cmd_escaped}\" --cwd \"$PWD\"");

    if let Some(ref prefix) = gen.strip_prefix {
        let prefix_escaped = escape_double_quote_string(prefix);
        synapse_cmd.push_str(&format!(" --strip-prefix \"{prefix_escaped}\""));
    }

    if gen.split_on != "\n" {
        let split_escaped = escape_double_quote_string(&gen.split_on);
        synapse_cmd.push_str(&format!(" --split-on \"{split_escaped}\""));
    }

    // synapse run-generator outputs one value per line, so always split on newlines
    format!("{{local -a vals; vals=(${{(f)\"$({synapse_cmd} 2>/dev/null)\"}}); compadd -a vals}}")
}

/// Escape a string for use inside double quotes in shell.
fn escape_double_quote_string(s: &str) -> String {
    s.replace('\\', "\\\\")
        .replace('"', "\\\"")
        .replace('$', "\\$")
        .replace('`', "\\`")
}

/// Escape a string for use inside zsh single-quoted contexts.
/// Single quotes inside _arguments descriptions need special handling.
fn escape_zsh_string(s: &str) -> String {
    s.replace('\'', "'\\''")
        .replace('[', "\\[")
        .replace(']', "\\]")
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::spec::*;

    #[test]
    fn test_format_option_short_and_long_flag() {
        let opt = OptionSpec {
            short: Some("-v".into()),
            long: Some("--verbose".into()),
            description: Some("Verbose".into()),
            takes_arg: false,
            ..Default::default()
        };
        let result = format_option(&opt);
        assert_eq!(result, "'(-v --verbose)'{-v,--verbose}'[Verbose]'");
    }

    #[test]
    fn test_format_option_short_and_long_with_arg() {
        let opt = OptionSpec {
            short: Some("-o".into()),
            long: Some("--output".into()),
            description: Some("Output file".into()),
            takes_arg: true,
            ..Default::default()
        };
        let result = format_option(&opt);
        assert_eq!(result, "'(-o --output)'{-o,--output=}'[Output file]': :");
    }

    #[test]
    fn test_format_option_long_only_with_arg() {
        let opt = OptionSpec {
            long: Some("--port".into()),
            description: Some("Port".into()),
            takes_arg: true,
            ..Default::default()
        };
        let result = format_option(&opt);
        assert_eq!(result, "'--port=[Port]': :");
    }

    #[test]
    fn test_format_option_short_only_with_arg() {
        let opt = OptionSpec {
            short: Some("-j".into()),
            description: Some("Jobs".into()),
            takes_arg: true,
            ..Default::default()
        };
        let result = format_option(&opt);
        assert_eq!(result, "'-j[Jobs]': :");
    }

    #[test]
    fn test_format_option_long_only_flag() {
        let opt = OptionSpec {
            long: Some("--release".into()),
            description: Some("Build in release mode".into()),
            takes_arg: false,
            ..Default::default()
        };
        let result = format_option(&opt);
        assert_eq!(result, "'--release[Build in release mode]'");
    }

    #[test]
    fn test_format_arg_file_paths() {
        let arg = ArgSpec {
            name: "file".into(),
            template: Some(ArgTemplate::FilePaths),
            variadic: true,
            ..Default::default()
        };
        assert_eq!(format_arg(&arg), "'*:file:_files'");
    }

    #[test]
    fn test_format_arg_directories() {
        let arg = ArgSpec {
            name: "dir".into(),
            template: Some(ArgTemplate::Directories),
            ..Default::default()
        };
        assert_eq!(format_arg(&arg), "':directory:_files -/'");
    }

    #[test]
    fn test_format_arg_env_vars() {
        let arg = ArgSpec {
            name: "var".into(),
            template: Some(ArgTemplate::EnvVars),
            ..Default::default()
        };
        assert_eq!(format_arg(&arg), "':variable:_parameters -g \"*(export)\"'");
    }

    #[test]
    fn test_format_arg_suggestions() {
        let arg = ArgSpec {
            name: "color".into(),
            suggestions: vec!["auto".into(), "always".into(), "never".into()],
            ..Default::default()
        };
        assert_eq!(format_arg(&arg), "':color:(auto always never)'");
    }

    #[test]
    fn test_format_arg_generator() {
        let arg = ArgSpec {
            name: "branch".into(),
            generator: Some(GeneratorSpec {
                command: "git branch --no-color".into(),
                strip_prefix: Some("* ".into()),
                split_on: "\n".into(),
                ..Default::default()
            }),
            ..Default::default()
        };
        let result = format_arg(&arg);
        assert!(
            result.contains("synapse run-generator"),
            "expected synapse run-generator, got: {result}"
        );
        assert!(
            result.contains("git branch --no-color"),
            "expected generator command, got: {result}"
        );
        assert!(
            result.contains("--strip-prefix"),
            "expected --strip-prefix flag, got: {result}"
        );
        assert!(
            result.contains("compadd"),
            "expected compadd, got: {result}"
        );
    }

    #[test]
    fn test_format_arg_generator_escapes_special_chars() {
        let arg = ArgSpec {
            name: "column".into(),
            generator: Some(GeneratorSpec {
                command: "awk '{print $1}' /some/file".into(),
                split_on: "\n".into(),
                ..Default::default()
            }),
            ..Default::default()
        };
        let result = format_arg(&arg);
        // The command is passed as a double-quoted argument to synapse run-generator.
        // $ and ` in the command must be escaped for the double-quote context.
        assert!(
            result.contains("synapse run-generator"),
            "Expected synapse run-generator, got: {result}"
        );
        // The $1 should be escaped as \$1 inside the double-quoted argument
        assert!(
            result.contains("\\$1"),
            "Expected escaped dollar sign, got: {result}"
        );
    }

    #[test]
    fn test_export_simple_command() {
        let spec = CommandSpec {
            name: "myapp".into(),
            options: vec![OptionSpec {
                short: Some("-v".into()),
                long: Some("--verbose".into()),
                description: Some("Verbose output".into()),
                takes_arg: false,
                ..Default::default()
            }],
            args: vec![ArgSpec {
                name: "file".into(),
                template: Some(ArgTemplate::FilePaths),
                variadic: true,
                ..Default::default()
            }],
            ..Default::default()
        };
        let output = export_command_spec(&spec);
        assert!(output.contains("#compdef myapp"));
        assert!(output.contains("_myapp()"));
        assert!(output.contains("_arguments"));
        assert!(output.contains("--verbose"));
        assert!(output.contains("_files"));
        assert!(output.contains("_myapp \"$@\""));
    }

    #[test]
    fn test_export_recursive_command() {
        let spec = CommandSpec {
            name: "sudo".into(),
            recursive: true,
            options: vec![OptionSpec {
                short: Some("-u".into()),
                description: Some("Run as user".into()),
                takes_arg: true,
                ..Default::default()
            }],
            ..Default::default()
        };
        let output = export_command_spec(&spec);
        assert!(output.contains("_command_names -e"));
        assert!(output.contains("*::args:_normal"));
    }

    #[test]
    fn test_export_command_with_subcommands() {
        let spec = CommandSpec {
            name: "cargo".into(),
            options: vec![OptionSpec {
                short: Some("-V".into()),
                long: Some("--version".into()),
                description: Some("Print version".into()),
                takes_arg: false,
                ..Default::default()
            }],
            subcommands: vec![
                SubcommandSpec {
                    name: "build".into(),
                    aliases: vec!["b".into()],
                    description: Some("Compile the current package".into()),
                    options: vec![OptionSpec {
                        long: Some("--release".into()),
                        description: Some("Build in release mode".into()),
                        takes_arg: false,
                        ..Default::default()
                    }],
                    ..Default::default()
                },
                SubcommandSpec {
                    name: "test".into(),
                    aliases: vec!["t".into()],
                    description: Some("Run tests".into()),
                    ..Default::default()
                },
            ],
            ..Default::default()
        };
        let output = export_command_spec(&spec);
        assert!(output.contains("#compdef cargo"));
        assert!(output.contains("_cargo()"));
        assert!(output.contains("_arguments -C"));
        assert!(output.contains("'1:command:->cmd'"));
        assert!(output.contains("*::args:->args"));
        assert!(output.contains("'build:Compile the current package'"));
        assert!(output.contains("'test:Run tests'"));
        assert!(output.contains("(build|b) _cargo_build"));
        assert!(output.contains("(test|t) _cargo_test"));
        assert!(output.contains("_cargo_build()"));
        assert!(output.contains("--release"));
    }

    #[test]
    fn test_export_nested_subcommands() {
        let spec = CommandSpec {
            name: "git".into(),
            subcommands: vec![SubcommandSpec {
                name: "stash".into(),
                description: Some("Stash changes".into()),
                subcommands: vec![
                    SubcommandSpec {
                        name: "push".into(),
                        description: Some("Save modifications".into()),
                        options: vec![OptionSpec {
                            short: Some("-m".into()),
                            long: Some("--message".into()),
                            description: Some("Stash message".into()),
                            takes_arg: true,
                            ..Default::default()
                        }],
                        ..Default::default()
                    },
                    SubcommandSpec {
                        name: "pop".into(),
                        description: Some("Apply and remove stash".into()),
                        ..Default::default()
                    },
                ],
                ..Default::default()
            }],
            ..Default::default()
        };
        let output = export_command_spec(&spec);
        assert!(output.contains("_git_stash()"));
        assert!(output.contains("_git_stash_push()"));
        assert!(output.contains("_git_stash_pop()"));
        assert!(output.contains("'push:Save modifications'"));
        assert!(output.contains("--message"));
    }

    #[test]
    fn test_export_command_with_aliases() {
        let spec = CommandSpec {
            name: "cargo".into(),
            aliases: vec!["cg".into()],
            ..Default::default()
        };
        let output = export_command_spec(&spec);
        assert!(output.contains("compdef _cargo cg"));
    }

    #[test]
    fn test_write_completion_file() {
        let dir = tempfile::tempdir().unwrap();
        let spec = CommandSpec {
            name: "testcmd".into(),
            ..Default::default()
        };
        let path = write_completion_file(&spec, dir.path()).unwrap();
        assert_eq!(path.file_name().unwrap(), "_testcmd");
        assert!(path.exists());
        let content = std::fs::read_to_string(&path).unwrap();
        assert!(content.contains("#compdef testcmd"));
    }

    #[test]
    fn test_generate_all_gap_only() {
        let dir = tempfile::tempdir().unwrap();
        let mut existing = HashSet::new();
        existing.insert("rg".to_string());

        let specs = vec![
            CommandSpec {
                name: "rg".into(),
                source: SpecSource::Discovered,
                ..Default::default()
            },
            CommandSpec {
                name: "fd".into(),
                source: SpecSource::Discovered,
                ..Default::default()
            },
        ];

        let report = generate_all(&specs, &existing, dir.path(), true).unwrap();
        assert_eq!(report.generated, vec!["fd"]);
        assert_eq!(report.skipped_existing, vec!["rg"]);
    }

    #[test]
    fn test_generate_all_project_auto_always_generates() {
        let dir = tempfile::tempdir().unwrap();
        let mut existing = HashSet::new();
        existing.insert("make".to_string());

        let specs = vec![CommandSpec {
            name: "make".into(),
            source: SpecSource::ProjectAuto,
            ..Default::default()
        }];

        let report = generate_all(&specs, &existing, dir.path(), true).unwrap();
        assert_eq!(report.generated, vec!["make"]);
        assert!(report.skipped_existing.is_empty());
    }

    #[test]
    fn test_format_generator_action_with_strip_prefix() {
        let gen = GeneratorSpec {
            command: "git branch --no-color".into(),
            strip_prefix: Some("* ".into()),
            split_on: "\n".into(),
            ..Default::default()
        };
        let action = format_generator_action(&gen);
        assert!(
            action.contains("synapse run-generator"),
            "expected synapse run-generator, got: {action}"
        );
        assert!(
            action.contains("git branch --no-color"),
            "expected generator command, got: {action}"
        );
        assert!(
            action.contains("--strip-prefix"),
            "expected --strip-prefix flag, got: {action}"
        );
        assert!(
            action.contains("* "),
            "expected strip prefix value, got: {action}"
        );
        assert!(
            action.contains("compadd -a vals"),
            "expected compadd, got: {action}"
        );
    }

    #[test]
    fn test_format_generator_action_simple() {
        let gen = GeneratorSpec {
            command: "git remote".into(),
            split_on: "\n".into(),
            ..Default::default()
        };
        let action = format_generator_action(&gen);
        assert!(
            action.contains("synapse run-generator"),
            "expected synapse run-generator, got: {action}"
        );
        assert!(
            action.contains("git remote"),
            "expected generator command, got: {action}"
        );
        assert!(
            action.contains("(f)"),
            "expected (f) split flag, got: {action}"
        );
        assert!(
            !action.contains("--strip-prefix"),
            "should not have --strip-prefix, got: {action}"
        );
        assert!(
            !action.contains("--split-on"),
            "should not have --split-on for default newline, got: {action}"
        );
    }

    #[test]
    fn test_escape_zsh_string() {
        assert_eq!(escape_zsh_string("hello"), "hello");
        assert_eq!(escape_zsh_string("it's"), "it'\\''s");
        assert_eq!(escape_zsh_string("[test]"), "\\[test\\]");
    }

    #[test]
    fn test_option_with_arg_generator() {
        let opt = OptionSpec {
            long: Some("--color".into()),
            description: Some("Coloring".into()),
            takes_arg: true,
            arg_generator: None,
            ..Default::default()
        };
        let result = format_option(&opt);
        assert_eq!(result, "'--color=[Coloring]': :");
    }

    #[test]
    fn test_completions_dir() {
        let dir = completions_dir();
        assert!(dir.ends_with(".synapse/completions"));
    }

    #[test]
    fn test_remove_stale_project_auto() {
        let dir = tempfile::tempdir().unwrap();

        // Write a project-auto file that will become stale
        let stale = CommandSpec {
            name: "make".into(),
            source: SpecSource::ProjectAuto,
            ..Default::default()
        };
        write_completion_file(&stale, dir.path()).unwrap();

        // Write a project-auto file that will be regenerated
        let current = CommandSpec {
            name: "npm".into(),
            source: SpecSource::ProjectAuto,
            ..Default::default()
        };
        write_completion_file(&current, dir.path()).unwrap();

        // Write a discovered file — should never be removed
        let discovered = CommandSpec {
            name: "git".into(),
            source: SpecSource::Discovered,
            ..Default::default()
        };
        write_completion_file(&discovered, dir.path()).unwrap();

        // Write a non-synapse file — should never be removed
        std::fs::write(dir.path().join("_custom"), "# custom completion\n").unwrap();

        let generated = HashSet::from(["npm".to_string()]);
        let removed = remove_stale_project_auto(dir.path(), &generated).unwrap();

        assert_eq!(removed, vec!["make"]);
        assert!(!dir.path().join("_make").exists());
        assert!(dir.path().join("_npm").exists());
        assert!(dir.path().join("_git").exists());
        assert!(dir.path().join("_custom").exists());
    }

    #[test]
    fn test_remove_stale_project_auto_nonexistent_dir() {
        let dir = tempfile::tempdir().unwrap();
        let missing = dir.path().join("nonexistent");
        let removed = remove_stale_project_auto(&missing, &HashSet::new()).unwrap();
        assert!(removed.is_empty());
    }
}
